<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mindora - Mind Map</title>
    <!-- Google Font for a modern, professional look -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Global reset and body styling */
      body {
        margin: 0;
        overflow: hidden; /* No page scroll */
        font-family: 'Roboto', sans-serif;
        background: #f4f4f4;
      }
      /* Full-screen canvas */
      canvas {
        display: block;
        background: white;
      }
      /* Toolbar styling */
      #toolbar {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(51, 51, 51, 0.9);
        padding: 8px 12px;
        border-radius: 12px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 6px;
        z-index: 10;
        font-size: 12px;
      }
      #toolbar button,
      #toolbar input[type="color"] {
        background: #ffd700;
        color: #333;
        border: none;
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 6px;
        transition: background 0.3s;
      }
      #toolbar button:hover {
        background: #e6c200;
      }
      #toolbar input[type="color"] {
        width: 28px;
        height: 28px;
      }
      #toolbar span {
        color: #fff;
        margin-left: 4px;
      }
      .imgScaleBtn {
        background: #ffd700;
        font-weight: bold;
      }
      /* Toggle Toolbar Button (always visible) */
      #toggleToolbar {
        position: fixed;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        background: #ffd700;
        color: #333;
        border: none;
        padding: 6px 10px;
        cursor: pointer;
        border-radius: 0 6px 6px 0;
        z-index: 100;
        transition: background 0.3s;
      }
      #toggleToolbar:hover {
        background: #e6c200;
      }
      /* Common modal styles ‚Äì both editor and config share these */
      #editorModal,
      #configModal {
        display: none;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 16px;
        z-index: 20;
        width: 320px;
        /* Ensures the modals scale down on smaller screens */
        max-width: 90vw;
        max-height: 90vh;
        overflow: auto;
        box-sizing: border-box;
      }
      /* The modal header acts as a drag handle */
      .modalHeader {
        font-size: 16px;
        margin: 0;
        cursor: move;
        user-select: none;
        padding-bottom: 8px;
        border-bottom: 1px solid #ccc;
      }
      /* Editor modal content area styling */
      #editorArea {
        width: 100%;
        height: 150px;
        border: 1px solid #ccc;
        padding: 8px;
        margin-top: 8px;
        overflow-y: auto;
        overflow-x: hidden;
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #fefefe;
        border-radius: 4px;
        box-sizing: border-box;
      }
      #charCount {
        font-size: 10px;
        text-align: right;
        margin-top: 4px;
        color: #666;
      }
      #editorModal button,
      #configModal button {
        margin-top: 8px;
        padding: 4px 8px;
        cursor: pointer;
        background: #ffd700;
        border: none;
        border-radius: 4px;
        transition: background 0.3s;
      }
      #editorModal button:hover,
      #configModal button:hover {
        background: #e6c200;
      }
      /* Config modal inputs */
      #configModal label {
        display: block;
        margin-top: 6px;
        font-size: 12px;
      }
      #configModal input[type="color"],
      #configModal input[type="number"] {
        margin-top: 2px;
        width: 100%;
        padding: 2px;
        box-sizing: border-box;
      }
      #configModal select {
        margin-top: 2px;
        width: 100%;
        padding: 2px;
        box-sizing: border-box;
      }
      #configModal .edgeGlobalContainer {
        margin-top: 6px;
        font-size: 12px;
      }
      #configModal .selectedHighlightLabel {
        margin-top: 6px;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <!-- Toolbar -->
    <div id="toolbar">
      <button onclick="newFile()" title="New File">New</button>
      <button onclick="addCircle()" title="Add Circle">‚óã</button>
      <button onclick="addSquare()" title="Add Square">‚ñ°</button>
      <button onclick="addTriangle()" title="Add Triangle">‚ñ≥</button>
      <button onclick="addRectangle()" title="Add Rectangle">‚ñ≠</button>
      <button onclick="addVerticalRect()" title="Add Vertical Rectangle">‚ñØ</button>
      <button onclick="addFloatingText()" title="Add Floating Text">‚ì£</button>
      <button onclick="addImage()" title="Add Image">Image</button>
      <button class="imgScaleBtn" onclick="scaleImage(0.1)" title="Increase Size">+</button>
      <button class="imgScaleBtn" onclick="scaleImage(-0.1)" title="Decrease Size">‚Äì</button>
      <button onclick="setMode(Mode.CONNECT)" title="Connect">‚Üî</button>
      <button onclick="setMode(Mode.DISCONNECT)" title="Disconnect">‚Üê√ó‚Üí</button>
      <button onclick="setMode(Mode.SELECT)" title="Select/Move">‚òö</button>
      <button onclick="deleteNode()" title="Delete Node">‚úñ</button>
      <button onclick="openConfig()" title="Configure Selected Node/Edges">Config</button>
      <button onclick="saveAsImage()" title="Save as PNG">Save PNG</button>
      <button onclick="saveAsJpeg()" title="Save as JPEG">Save JPEG</button>
      <button onclick="saveJSON()" title="Save JSON">Save JSON</button>
      <button onclick="loadJSON()" title="Load JSON">Load JSON</button>
      <button onclick="undo()" title="Undo (Ctrl+Z)">Undo</button>
      <button onclick="redo()" title="Redo (Ctrl+Shift+Z)">Redo</button>
      <button onclick="zoomIn()" title="Zoom In">Ôºã</button>
      <button onclick="zoomOut()" title="Zoom Out">Ôºç</button>
      <span id="status">Mode: Select/Move | Zoom: 100%</span>
    </div>

    <!-- Toggle Toolbar Button (always visible) -->
    <button id="toggleToolbar" onclick="toggleToolbar()" title="Toggle Menu">üëÅ</button>

    <!-- Editor Modal -->
    <div id="editorModal">
      <div class="modalHeader">Edit Node Text</div>
      <div
        id="editorArea"
        contenteditable="true"
      ></div>
      <div id="charCount">Characters: 0</div>
      <label style="font-size:12px; margin-top:4px;">
        <input type="checkbox" id="readingMode" /> Reading Mode
      </label>
      <div style="text-align:right; margin-top:8px;">
        <button onclick="closeEditor(true)">OK</button>
        <button onclick="closeEditor(false)">Cancel</button>
      </div>
    </div>

    <!-- Config Modal -->
    <div id="configModal">
      <div class="modalHeader">Configure</div>
      <div id="nodeConfig">
        <label>Fill Color:
          <input type="color" id="configFill" value="#FFD700" />
        </label>
        <label>Text Color:
          <input type="color" id="configText" value="#000000" />
        </label>
        <label>Border Color:
          <input type="color" id="configBorder" value="#333333" />
        </label>
        <label>Stroke Thickness:
          <input type="number" id="configStroke" value="2" min="1" step="0.5" />
        </label>
        <label>Manual Scale (for node size):
          <input type="number" id="configScale" value="1" min="0.1" step="0.1" />
        </label>
        <label>Font Family:
          <select id="configFont">
            <option value="Roboto, Arial, sans-serif">Roboto</option>
            <option value="Arial, sans-serif">Arial</option>
            <option value="Times New Roman, serif">Times New Roman</option>
            <option value="Courier New, monospace">Courier New</option>
          </select>
        </label>
        <label>Font Size:
          <input type="number" id="configFontSize" value="16" min="8" max="72" step="1" />
        </label>
        <label>
          <input type="checkbox" id="configBold" /> Bold
        </label>
        <label>
          <input type="checkbox" id="configItalic" /> Italic
        </label>
        <!-- Rich Text Checkbox -->
        <label>
          <input type="checkbox" id="configRichText" /> Show Rich Text Formatting in Node
        </label>
        <label class="selectedHighlightLabel">Selected Node Highlight Color:
          <input type="color" id="configHighlight" value="#add8e6" />
        </label>
      </div>
      <hr />
      <div id="edgeConfig">
        <label>Line Color:
          <input type="color" id="configLine" value="#777777" />
        </label>
        <label>Line Thickness:
          <input type="number" id="configLineThick" value="3" min="1" step="0.5" />
        </label>
        <div class="edgeGlobalContainer">
          <label>
            <input type="checkbox" id="edgeGlobal" /> Apply to all edges
          </label>
        </div>
      </div>
      <div style="text-align:right; margin-top:8px;">
        <button onclick="closeConfig(true)">Apply</button>
        <button onclick="closeConfig(false)">Cancel</button>
      </div>
    </div>

    <!-- Canvas -->
    <canvas id="mindmapCanvas"></canvas>

    <script>
      /**********************************
       * Global constants and variables *
       **********************************/
      const GOLDEN_RATIO = 1.618;
      const MIN_CIRCLE_HIT_RADIUS = 10;
      const MIN_CIRCLE_SCALE = 0.25;

      let zoomLevel = 1;
      let globalLineColor = document.getElementById("configLine").value;
      let globalLineThickness = parseFloat(document.getElementById("configLineThick").value);
      let selectedHighlightColor = document.getElementById("configHighlight").value;
      let nextNodeId = 1;
      let undoStack = [];
      let redoStack = [];
      let connectionSourceNode = null;

      // Global text measurement cache for performance
      const measureCache = new Map();
      function measureText(ctx, text) {
        const key = ctx.font + "|" + text;
        if (measureCache.has(key)) {
          return measureCache.get(key);
        }
        const widthVal = ctx.measureText(text).width;
        measureCache.set(key, widthVal);
        return widthVal;
      }

      const canvas = document.getElementById("mindmapCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let redrawScheduled = false;
      function scheduleDraw() {
        if (!redrawScheduled) {
          redrawScheduled = true;
          requestAnimationFrame(() => {
            mindMap.draw();
            redrawScheduled = false;
          });
        }
      }

      const Mode = { SELECT: 'select', CONNECT: 'connect', DISCONNECT: 'disconnect' };
      let currentMode = Mode.SELECT;

      /*******************************
       * Make modals always re-center
       *******************************/
      function centerModal(modal) {
        // Set initial position to center
        modal.style.left = "50%";
        modal.style.top = "50%";
        modal.style.transform = "translate(-50%, -50%)";
      }

      /***********************
       * Draggable Modals    *
       ***********************/
      function makeDraggable(el) {
        const header = el.querySelector(".modalHeader");
        if (!header) return;
        header.onmousedown = function (e) {
          e.preventDefault();
          let pos3 = e.clientX, pos4 = e.clientY;
          document.onmouseup = closeDragElement;
          document.onmousemove = elementDrag;

          function elementDrag(e) {
            e.preventDefault();
            let dx = e.clientX - pos3;
            let dy = e.clientY - pos4;
            pos3 = e.clientX;
            pos4 = e.clientY;
            el.style.left = (el.offsetLeft + dx) + "px";
            el.style.top = (el.offsetTop + dy) + "px";
            el.style.transform = ""; // remove transform so that it does not offset again
          }

          function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
          }
        };
        header.addEventListener("touchstart", function (e) {
          e.preventDefault();
          let startX = e.touches[0].clientX;
          let startY = e.touches[0].clientY;
          let initLeft = el.offsetLeft;
          let initTop = el.offsetTop;
          el.style.transform = ""; // reset transform so the offset doesn't stack

          function touchMove(ev) {
            ev.preventDefault();
            let dx = ev.touches[0].clientX - startX;
            let dy = ev.touches[0].clientY - startY;
            el.style.left = (initLeft + dx) + "px";
            el.style.top = (initTop + dy) + "px";
          }
          function touchEnd() {
            document.removeEventListener("touchmove", touchMove);
            document.removeEventListener("touchend", touchEnd);
          }
          document.addEventListener("touchmove", touchMove, { passive: false });
          document.addEventListener("touchend", touchEnd);
        }, { passive: false });
      }

      /*********************
       * Node Class
       *********************/
      class Node {
        constructor(x, y, text = "New Node", shape = 'circle', color = "#FFD700") {
          this.id = nextNodeId++;
          this.x = x;
          this.y = y;
          this.fullText = text || "New Node";
          this.text = this.fullText;
          this.shape = shape;
          this.color = color;
          this.textColor = "#000000";
          this.strokeColor = "#333333";
          this.strokeThickness = 2;
          this.manualScale = 1;
          this.fontFamily = "Roboto, Arial, sans-serif";
          this.fontSize = 16;
          this.fontWeight = "normal";
          this.fontStyle = "normal";
          this.image = null;
          this.richTextEnabled = false;
          this.html = null;
        }

        adjustSize(ctx) {
          if (this.shape === "image" && this.image) {
            const maxDimension = 200;
            let iw = this.image.naturalWidth;
            let ih = this.image.naturalHeight;
            let scale = Math.min(1, maxDimension / iw, maxDimension / ih);
            this.displayWidth = iw * scale * this.manualScale;
            this.displayHeight = ih * scale * this.manualScale;
            return;
          }

          ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
          const padding = 20;
          let measureTextValue;

          if (this.richTextEnabled && this.html) {
            measureTextValue = this.html
              .replace(/<\/p>/gi, "\n")
              .replace(/<br\s*\/?>/gi, "\n")
              .replace(/<[^>]+>/g, "")
              .trim() || "Empty";
          } else {
            measureTextValue = this.fullText.trim() || "Empty";
          }

          let lines = measureTextValue.split(/\r?\n/);
          let maxLineWidth = 0;
          for (let line of lines) {
            let w = measureText(ctx, line);
            if (w > maxLineWidth) maxLineWidth = w;
          }

          if (this.shape === 'circle') {
            let autoRadius = (maxLineWidth + padding) / 2;
            autoRadius = Math.max(40, autoRadius);
            this.displayRadius = autoRadius * this.manualScale;
          } else if (this.shape === 'square') {
            let autoSize = maxLineWidth + padding;
            autoSize = Math.max(autoSize, 40 * GOLDEN_RATIO);
            this.displayWidth = autoSize * this.manualScale;
            this.displayHeight = autoSize * this.manualScale;
          } else if (this.shape === 'rectangle') {
            let autoWidth = maxLineWidth + padding;
            autoWidth = Math.max(autoWidth, 40 * GOLDEN_RATIO);
            this.displayWidth = autoWidth * this.manualScale;
            this.displayHeight = (autoWidth / GOLDEN_RATIO) * this.manualScale;
          } else if (this.shape === 'triangle') {
            let autoWidth = maxLineWidth + padding;
            autoWidth = Math.max(autoWidth, 40 * GOLDEN_RATIO);
            this.displayWidth = autoWidth * this.manualScale;
            this.displayHeight = Math.round(autoWidth * Math.sqrt(3) / 2) * this.manualScale;
          } else if (this.shape === 'floating') {
            let textWidth = 0;
            for (let ln of lines) {
              textWidth = Math.max(textWidth, measureText(ctx, ln));
            }
            this.displayWidth = textWidth + 20;
            this.displayHeight = lines.length * (this.fontSize + 4) + 10;
          } else if (this.shape === 'verticalRect') {
            let autoHeight = maxLineWidth + padding;
            autoHeight = Math.max(autoHeight, 40 * GOLDEN_RATIO);
            let autoWidth = (autoHeight / GOLDEN_RATIO);
            this.displayHeight = autoHeight * this.manualScale;
            this.displayWidth = autoWidth * this.manualScale;
          }
        }

        draw(ctx) {
          this.adjustSize(ctx);
          ctx.textBaseline = "middle";

          if (this.shape === "image" && this.image) {
            ctx.drawImage(
              this.image,
              this.x - this.displayWidth / 2,
              this.y - this.displayHeight / 2,
              this.displayWidth,
              this.displayHeight
            );
            return;
          }

          if (this.shape !== "floating") {
            ctx.beginPath();
            if (this.shape === 'circle') {
              ctx.arc(this.x, this.y, this.displayRadius, 0, Math.PI * 2);
            } else if (
              this.shape === 'square' ||
              this.shape === 'rectangle' ||
              this.shape === 'verticalRect'
            ) {
              ctx.rect(
                this.x - this.displayWidth / 2,
                this.y - this.displayHeight / 2,
                this.displayWidth,
                this.displayHeight
              );
            } else if (this.shape === 'triangle') {
              const halfW = this.displayWidth / 2;
              const halfH = this.displayHeight / 2;
              ctx.moveTo(this.x, this.y - halfH);
              ctx.lineTo(this.x - halfW, this.y + halfH);
              ctx.lineTo(this.x + halfW, this.y + halfH);
              ctx.closePath();
            }
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.lineWidth = this.strokeThickness;
            ctx.strokeStyle = this.strokeColor;
            ctx.stroke();
          }

          ctx.save();
          if (this.shape === 'circle') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.max(0, this.displayRadius - 5), 0, Math.PI * 2);
            ctx.clip();
          } else if (
            this.shape === 'square' ||
            this.shape === 'rectangle' ||
            this.shape === 'verticalRect'
          ) {
            ctx.beginPath();
            ctx.rect(
              this.x - this.displayWidth / 2,
              this.y - this.displayHeight / 2,
              this.displayWidth,
              this.displayHeight
            );
            ctx.clip();
          } else if (this.shape === 'triangle') {
            ctx.beginPath();
            const halfW = this.displayWidth / 2;
            const halfH = this.displayHeight / 2;
            ctx.moveTo(this.x, this.y - halfH);
            ctx.lineTo(this.x - halfW, this.y + halfH);
            ctx.lineTo(this.x + halfW, this.y + halfH);
            ctx.closePath();
            ctx.clip();
          }

          // Show full text with formatting if enabled
          if (this.richTextEnabled && this.html) {
            drawRichText(ctx, this.x, this.y, this.html, this);
          } else {
            ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
            ctx.fillStyle = this.textColor;
            ctx.textAlign = "center";

            let sourceText = this.fullText.trim() || "Empty";
            let lines = sourceText.split(/\r?\n/);
            let firstLine = lines[0];
            let hasMore = lines.length > 1;

            let availableWidth;
            if (this.shape === 'circle') {
              availableWidth = (this.displayRadius - 5) * 2;
            } else if (this.shape === 'triangle') {
              availableWidth = Math.floor(this.displayWidth * 0.7);
            } else {
              availableWidth = this.displayWidth - 10;
            }

            let measured = measureText(ctx, firstLine);
            if (measured > availableWidth || hasMore) {
              while (firstLine.length > 0 && measureText(ctx, firstLine + "...") > availableWidth) {
                firstLine = firstLine.slice(0, -1);
              }
              firstLine += "...";
            }
            ctx.fillText(firstLine, this.x, this.y);
          }

          ctx.restore();
        }

        contains(x, y) {
          if (this.shape === 'circle') {
            const hitRadius = Math.max(this.displayRadius, MIN_CIRCLE_HIT_RADIUS);
            return Math.hypot(x - this.x, y - this.y) <= hitRadius;
          } else if (this.shape === "image") {
            return (
              x >= this.x - this.displayWidth / 2 &&
              x <= this.x + this.displayWidth / 2 &&
              y >= this.y - this.displayHeight / 2 &&
              y <= this.y + this.displayHeight / 2
            );
          } else {
            return (
              x >= this.x - this.displayWidth / 2 &&
              x <= this.x + this.displayWidth / 2 &&
              y >= this.y - this.displayHeight / 2 &&
              y <= this.y + this.displayHeight / 2
            );
          }
        }
      }

      /**********************
       * Rich Text Rendering
       **********************/
      function drawRichText(ctx, centerX, centerY, rawHtml, node) {
        let lines = parseHtmlIntoLines(rawHtml);
        if (lines.length === 0) {
          lines = [["Empty"]];
        }
        let lineHeight = node.fontSize + 4;
        let totalHeight = lines.length * lineHeight;
        let startY = centerY - totalHeight / 2 + lineHeight / 2;

        for (let i = 0; i < lines.length; i++) {
          let segments = lines[i];
          let totalLineWidth = 0;
          for (let seg of segments) {
            let actualFontStyle = seg.fontStyle === "italic" ? "italic" : "normal";
            let actualFontWeight = seg.fontWeight === "bold" ? "bold" : "normal";
            let actualFontSize = node.fontSize;
            let actualFontFamily = node.fontFamily;
            ctx.font = `${actualFontStyle} ${actualFontWeight} ${actualFontSize}px ${actualFontFamily}`;

            let segWidth = measureText(ctx, seg.text);
            seg.width = segWidth;
            totalLineWidth += segWidth;
          }
          let currentX = centerX - totalLineWidth / 2;

          for (let seg of segments) {
            let actualFontStyle = seg.fontStyle === "italic" ? "italic" : "normal";
            let actualFontWeight = seg.fontWeight === "bold" ? "bold" : "normal";
            let actualFontSize = node.fontSize;
            let actualFontFamily = node.fontFamily;

            ctx.font = `${actualFontStyle} ${actualFontWeight} ${actualFontSize}px ${actualFontFamily}`;
            ctx.fillStyle = node.textColor;
            ctx.textBaseline = "middle";
            ctx.textAlign = "left";

            ctx.fillText(seg.text, currentX, startY + i * lineHeight);
            currentX += seg.width;
          }
        }
      }

      function parseHtmlIntoLines(rawHtml) {
        // Convert <div> to <br>
        rawHtml = rawHtml.replace(/<div[^>]*>/gi, "<br>").replace(/<\/div>/gi, "");
        // Convert <p> to <br>, remove open <p>
        rawHtml = rawHtml.replace(/<\/p>/gi, "<br>").replace(/<p[^>]*>/gi, "");

        let lineHtmls = rawHtml.split(/<br\s*\/?>/i);
        let allLines = [];
        for (let lineHtml of lineHtmls) {
          let trimmed = lineHtml.trim();
          let segments = parseLineIntoSegments(trimmed);
          allLines.push(segments);
        }
        return allLines;
      }

      function parseLineIntoSegments(lineHtml) {
        let segments = [];
        let currentText = "";
        let isBold = false;
        let isItalic = false;

        let tokens = lineHtml.split(/(<\/?b>|<\/?i>|<\/?strong>|<\/?em>)/i);

        function pushSegmentIfNeeded() {
          if (currentText.length > 0) {
            segments.push({
              text: currentText,
              fontWeight: isBold ? "bold" : "normal",
              fontStyle: isItalic ? "italic" : "normal",
              fontSize: 16,
              fontFamily: "Roboto, Arial, sans-serif",
              fillStyle: "#000000",
              width: 0
            });
            currentText = "";
          }
        }

        for (let token of tokens) {
          let lower = token.toLowerCase();
          if (lower === "<b>" || lower === "<strong>") {
            pushSegmentIfNeeded();
            isBold = true;
          } else if (lower === "</b>" || lower === "</strong>") {
            pushSegmentIfNeeded();
            isBold = false;
          } else if (lower === "<i>" || lower === "<em>") {
            pushSegmentIfNeeded();
            isItalic = true;
          } else if (lower === "</i>" || lower === "</em>") {
            pushSegmentIfNeeded();
            isItalic = false;
          } else {
            currentText += token;
          }
        }
        pushSegmentIfNeeded();

        if (segments.length === 0) {
          segments.push({
            text: "",
            fontWeight: "normal",
            fontStyle: "normal",
            fontSize: 16,
            fontFamily: "Roboto, Arial, sans-serif",
            fillStyle: "#000000",
            width: 0
          });
        }

        for (let seg of segments) {
          seg.text = seg.text.replace(/\r?\n/g, " ");
        }
        return segments;
      }

      function cleanRichTextHTML(html) {
        html = html.replace(/<div[^>]*>/gi, "<br>").replace(/<\/div>/gi, "");
        const allowedTags = ['BR', 'B', 'I', 'STRONG', 'EM', 'P'];
        const temp = document.createElement('div');
        temp.innerHTML = html;
        function cleanNode(node) {
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            const child = node.childNodes[i];
            if (child.nodeType === Node.ELEMENT_NODE) {
              if (!allowedTags.includes(child.tagName)) {
                const text = child.textContent;
                const textNode = document.createTextNode(text);
                node.replaceChild(textNode, child);
              } else {
                cleanNode(child);
              }
            }
          }
        }
        cleanNode(temp);
        return temp.innerHTML;
      }

      /*********************
       * Edge Class
       *********************/
      class Edge {
        constructor(from, to) {
          this.from = from;
          this.to = to;
          this.lineThickness = globalLineThickness;
          this.lineColor = globalLineColor;
        }
        draw(ctx) {
          ctx.beginPath();
          ctx.moveTo(this.from.x, this.from.y);
          ctx.lineTo(this.to.x, this.to.y);
          ctx.strokeStyle = this.lineColor;
          ctx.lineWidth = this.lineThickness;
          ctx.stroke();
          ctx.closePath();
        }
      }

      /*********************
       * MindMap Class
       *********************/
      class MindMap {
        constructor(canvas, ctx) {
          this.canvas = canvas;
          this.ctx = ctx;
          this.nodes = [];
          this.edges = [];
          this.selectedNode = null;
          this.dragging = false;
          this.setupEvents();
        }

        getWorldCoords(event) {
          const rect = canvas.getBoundingClientRect();
          let clientX = event.clientX, clientY = event.clientY;
          if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
          }
          return {
            x: (clientX - rect.left) / zoomLevel,
            y: (clientY - rect.top) / zoomLevel
          };
        }

        setupEvents() {
          let longPressTimer = null;

          this.canvas.addEventListener("mousedown", (event) => {
            if (editorModal.style.display === "block") return;
            const { x, y } = this.getWorldCoords(event);
            let found = false;
            for (let i = this.nodes.length - 1; i >= 0; i--) {
              const node = this.nodes[i];
              if (node.contains(x, y)) {
                this.selectedNode = node;
                found = true;
                if (currentMode === Mode.SELECT) {
                  this.dragging = true;
                }
                if (currentMode === Mode.CONNECT || currentMode === Mode.DISCONNECT) {
                  if (!connectionSourceNode) {
                    connectionSourceNode = node;
                  } else if (connectionSourceNode !== node) {
                    if (currentMode === Mode.CONNECT) {
                      if (!this.edgeExists(connectionSourceNode, node)) {
                        this.edges.push(new Edge(connectionSourceNode, node));
                        pushState();
                      }
                    } else if (currentMode === Mode.DISCONNECT) {
                      this.removeEdge(connectionSourceNode, node);
                      pushState();
                    }
                    connectionSourceNode = null;
                  }
                }
                break;
              }
            }
            if (!found) {
              this.selectedNode = null;
            }
            scheduleDraw();
            updateStatus();
          });

          this.canvas.addEventListener("mousemove", (event) => {
            if (this.dragging && this.selectedNode && currentMode === Mode.SELECT) {
              const { x, y } = this.getWorldCoords(event);
              this.selectedNode.x = x;
              this.selectedNode.y = y;
              scheduleDraw();
            }
          });

          this.canvas.addEventListener("mouseup", () => {
            if (this.dragging) pushState();
            this.dragging = false;
          });

          this.canvas.addEventListener("dblclick", (event) => {
            if (editorModal.style.display === "block") return;
            const { x, y } = this.getWorldCoords(event);
            for (let node of this.nodes) {
              if (node.contains(x, y)) {
                openEditor(node);
                break;
              }
            }
          });

          this.canvas.addEventListener("touchstart", (event) => {
            event.preventDefault();
            const { x, y } = this.getWorldCoords(event);
            longPressTimer = setTimeout(() => {
              for (let i = this.nodes.length - 1; i >= 0; i--) {
                const node = this.nodes[i];
                if (node.contains(x, y)) {
                  openEditor(node);
                  break;
                }
              }
              longPressTimer = null;
            }, 600);
            let found = false;
            for (let i = this.nodes.length - 1; i >= 0; i--) {
              const node = this.nodes[i];
              if (node.contains(x, y)) {
                this.selectedNode = node;
                found = true;
                if (currentMode === Mode.SELECT) {
                  this.dragging = true;
                }
                if (currentMode === Mode.CONNECT || currentMode === Mode.DISCONNECT) {
                  if (!connectionSourceNode) {
                    connectionSourceNode = node;
                  } else if (connectionSourceNode !== node) {
                    if (currentMode === Mode.CONNECT) {
                      if (!this.edgeExists(connectionSourceNode, node)) {
                        this.edges.push(new Edge(connectionSourceNode, node));
                        pushState();
                      }
                    } else if (currentMode === Mode.DISCONNECT) {
                      this.removeEdge(connectionSourceNode, node);
                      pushState();
                    }
                    connectionSourceNode = null;
                  }
                }
                break;
              }
            }
            if (!found) {
              this.selectedNode = null;
            }
            scheduleDraw();
            updateStatus();
          }, { passive: false });

          this.canvas.addEventListener("touchmove", (event) => {
            event.preventDefault();
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            if (this.dragging && this.selectedNode && currentMode === Mode.SELECT) {
              const { x, y } = this.getWorldCoords(event);
              this.selectedNode.x = x;
              this.selectedNode.y = y;
              scheduleDraw();
            }
          }, { passive: false });

          this.canvas.addEventListener("touchend", () => {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            if (this.dragging) pushState();
            this.dragging = false;
          });
        }

        edgeExists(nodeA, nodeB) {
          return this.edges.some(
            (edge) =>
              (edge.from === nodeA && edge.to === nodeB) ||
              (edge.from === nodeB && edge.to === nodeA)
          );
        }

        removeEdge(nodeA, nodeB) {
          this.edges = this.edges.filter(
            (edge) =>
              !(
                (edge.from === nodeA && edge.to === nodeB) ||
                (edge.from === nodeB && edge.to === nodeA)
              )
          );
          scheduleDraw();
        }

        addNode(node) {
          if (node.fullText.trim() === "" && node.shape !== "image") return;
          this.nodes.push(node);
          scheduleDraw();
          pushState();
        }

        deleteNode(node) {
          this.nodes = this.nodes.filter((n) => n !== node);
          this.edges = this.edges.filter(
            (edge) => edge.from !== node && edge.to !== node
          );
          if (this.selectedNode === node) {
            this.selectedNode = null;
          }
          scheduleDraw();
          pushState();
        }

        draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.scale(zoomLevel, zoomLevel);

          // Draw edges
          for (let edge of this.edges) {
            edge.draw(ctx);
          }

          // Draw nodes
          for (let node of this.nodes) {
            node.draw(ctx);
            // highlight if selected
            if (node === this.selectedNode) {
              ctx.save();
              ctx.strokeStyle = selectedHighlightColor;
              ctx.lineWidth = 4;
              if (node.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.displayRadius + 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.closePath();
              } else if (
                node.shape === 'square' ||
                node.shape === 'rectangle' ||
                node.shape === 'verticalRect' ||
                node.shape === 'floating' ||
                node.shape === 'image'
              ) {
                ctx.strokeRect(
                  node.x - node.displayWidth / 2 - 4,
                  node.y - node.displayHeight / 2 - 4,
                  node.displayWidth + 8,
                  node.displayHeight + 8
                );
              } else if (node.shape === 'triangle') {
                const halfW = node.displayWidth / 2;
                const halfH = node.displayHeight / 2;
                ctx.beginPath();
                ctx.moveTo(node.x, node.y - halfH - 4);
                ctx.lineTo(node.x - halfW - 4, node.y + halfH + 4);
                ctx.lineTo(node.x + halfW + 4, node.y + halfH + 4);
                ctx.closePath();
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          ctx.restore();
        }

        getState() {
          return {
            nodes: this.nodes.map((n) => ({
              id: n.id,
              x: n.x,
              y: n.y,
              fullText: n.fullText,
              text: n.text,
              richTextEnabled: n.richTextEnabled,
              html: n.html,
              shape: n.shape,
              color: n.color,
              textColor: n.textColor,
              strokeColor: n.strokeColor,
              strokeThickness: n.strokeThickness,
              manualScale: n.manualScale,
              fontFamily: n.fontFamily,
              fontSize: n.fontSize,
              fontWeight: n.fontWeight,
              fontStyle: n.fontStyle,
              imageSrc: n.image ? n.image.src : null,
            })),
            edges: this.edges.map((e) => ({
              from: e.from.id,
              to: e.to.id,
              lineThickness: e.lineThickness,
              lineColor: e.lineColor,
            })),
          };
        }

        setState(state) {
          const nodeMap = {};
          this.nodes = state.nodes.map((nState) => {
            const node = new Node(
              nState.x,
              nState.y,
              nState.fullText,
              nState.shape,
              nState.color
            );
            node.id = nState.id;
            node.text = nState.text;
            node.textColor = nState.textColor;
            node.strokeColor = nState.strokeColor;
            node.strokeThickness = nState.strokeThickness;
            node.manualScale = nState.manualScale;
            node.fontFamily = nState.fontFamily || "Roboto, Arial, sans-serif";
            node.fontSize = nState.fontSize || 16;
            node.fontWeight = nState.fontWeight || "normal";
            node.fontStyle = nState.fontStyle || "normal";
            node.richTextEnabled = nState.richTextEnabled || false;
            node.html = nState.html || null;
            if (nState.imageSrc) {
              node.image = new Image();
              node.image.src = nState.imageSrc;
            }
            nodeMap[node.id] = node;
            return node;
          });

          this.edges = state.edges.map((edgeState) => {
            return new Edge(
              nodeMap[edgeState.from],
              nodeMap[edgeState.to]
            );
          });
          scheduleDraw();
        }
      }

      const mindMap = new MindMap(canvas, ctx);

      /*************************
       * Editor Modal
       *************************/
      const editorModal = document.getElementById("editorModal");
      const editorArea = document.getElementById("editorArea");
      const charCount = document.getElementById("charCount");
      let editingNode = null;

      function openEditor(node) {
        // Re-center the editor modal
        centerModal(editorModal);

        editingNode = node;
        if (node.richTextEnabled && node.html) {
          editorArea.innerHTML = node.html;
        } else {
          editorArea.innerText = node.fullText;
        }
        charCount.textContent = "Characters: " + (editorArea.innerText || "").length;
        editorArea.contentEditable = "true";
        document.execCommand("defaultParagraphSeparator", false, "br");
        makeDraggable(editorModal);
        editorModal.style.display = "block";
      }

      editorArea.addEventListener("input", () => {
        charCount.textContent = "Characters: " + (editorArea.innerText || "").length;
      });

      function closeEditor(save) {
        if (save && editingNode) {
          let newText = editorArea.innerText.trim();
          if (newText === "" || newText.toLowerCase() === "<br>") {
            alert("Node text cannot be empty.");
            return;
          }
          editingNode.fullText = newText;
          editingNode.text = newText;

          if (document.getElementById("configRichText").checked) {
            editingNode.richTextEnabled = true;
            editingNode.html = cleanRichTextHTML(editorArea.innerHTML);
          } else {
            editingNode.richTextEnabled = false;
            editingNode.html = null;
          }
          scheduleDraw();
          pushState();
        }
        editorModal.style.display = "none";
        editingNode = null;
      }

      /*************************
       * Config Modal
       *************************/
      const configModal = document.getElementById("configModal");
      function openConfig() {
        // Re-center the config modal
        centerModal(configModal);

        if (mindMap.selectedNode) {
          const node = mindMap.selectedNode;
          document.getElementById("configFill").value = node.color;
          document.getElementById("configText").value = node.textColor;
          document.getElementById("configBorder").value = node.strokeColor;
          document.getElementById("configStroke").value = node.strokeThickness;
          document.getElementById("configScale").value = node.manualScale;
          document.getElementById("configFont").value = node.fontFamily;
          document.getElementById("configFontSize").value = node.fontSize;
          document.getElementById("configBold").checked = (node.fontWeight === "bold");
          document.getElementById("configItalic").checked = (node.fontStyle === "italic");
          document.getElementById("configRichText").checked = node.richTextEnabled;
        }
        document.getElementById("configLine").value = globalLineColor;
        document.getElementById("configLineThick").value = globalLineThickness;
        document.getElementById("configHighlight").value = selectedHighlightColor;
        configModal.style.display = "block";
        makeDraggable(configModal);
      }

      function closeConfig(apply) {
        if (apply && mindMap.selectedNode) {
          let node = mindMap.selectedNode;
          node.color = document.getElementById("configFill").value;
          node.textColor = document.getElementById("configText").value;
          node.strokeColor = document.getElementById("configBorder").value;
          node.strokeThickness = parseFloat(document.getElementById("configStroke").value);
          node.manualScale = parseFloat(document.getElementById("configScale").value);
          node.fontFamily = document.getElementById("configFont").value;
          node.fontSize = parseInt(document.getElementById("configFontSize").value);
          node.fontWeight = document.getElementById("configBold").checked ? "bold" : "normal";
          node.fontStyle = document.getElementById("configItalic").checked ? "italic" : "normal";
          node.richTextEnabled = document.getElementById("configRichText").checked;
        }
        if (document.getElementById("edgeGlobal").checked || !mindMap.selectedNode) {
          globalLineColor = document.getElementById("configLine").value;
          globalLineThickness = parseFloat(document.getElementById("configLineThick").value);
          for (let edge of mindMap.edges) {
            edge.lineColor = globalLineColor;
            edge.lineThickness = globalLineThickness;
          }
        } else if (mindMap.selectedNode) {
          const newEdgeColor = document.getElementById("configLine").value;
          const newEdgeThickness = parseFloat(document.getElementById("configLineThick").value);
          for (let edge of mindMap.edges) {
            if (edge.from === mindMap.selectedNode || edge.to === mindMap.selectedNode) {
              edge.lineColor = newEdgeColor;
              edge.lineThickness = newEdgeThickness;
            }
          }
        }
        selectedHighlightColor = document.getElementById("configHighlight").value;
        configModal.style.display = "none";
        scheduleDraw();
        pushState();
      }

      /**************************
       * Undo/Redo & JSON
       **************************/
      function pushState() {
        undoStack.push(JSON.stringify(mindMap.getState()));
        redoStack = [];
      }
      function undo() {
        if (undoStack.length > 0) {
          redoStack.push(JSON.stringify(mindMap.getState()));
          const prev = JSON.parse(undoStack.pop());
          mindMap.setState(prev);
        }
      }
      function redo() {
        if (redoStack.length > 0) {
          undoStack.push(JSON.stringify(mindMap.getState()));
          const next = JSON.parse(redoStack.pop());
          mindMap.setState(next);
        }
      }
      function saveJSON() {
        const stateStr = JSON.stringify(mindMap.getState(), null, 2);
        const blob = new Blob([stateStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "mindmap.json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
      function loadJSON() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = (event) => {
            const state = JSON.parse(event.target.result);
            mindMap.setState(state);
            pushState();
          };
          reader.readAsText(file);
        };
        input.click();
      }

      /***********************
       * Toolbar Functions
       ***********************/
      function newFile() {
        if (mindMap.nodes.length > 0) {
          if (confirm("Save current file before creating a new one?")) {
            saveJSON();
          }
        }
        mindMap.setState({ nodes: [], edges: [] });
        pushState();
      }

      function addCircle() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const fill = document.getElementById("configFill").value || "#FFD700";
        const node = new Node(x, y, "New Circle", "circle", fill);
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = document.getElementById("configBorder").value || "#333333";
        node.strokeThickness = parseFloat(document.getElementById("configStroke").value) || 2;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addSquare() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const fill = document.getElementById("configFill").value || "#FFD700";
        const node = new Node(x, y, "New Square", "square", fill);
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = document.getElementById("configBorder").value || "#333333";
        node.strokeThickness = parseFloat(document.getElementById("configStroke").value) || 2;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addTriangle() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const fill = document.getElementById("configFill").value || "#FFD700";
        const node = new Node(x, y, "New Triangle", "triangle", fill);
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = document.getElementById("configBorder").value || "#333333";
        node.strokeThickness = parseFloat(document.getElementById("configStroke").value) || 2;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addRectangle() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const fill = document.getElementById("configFill").value || "#FFD700";
        const node = new Node(x, y, "New Rectangle", "rectangle", fill);
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = document.getElementById("configBorder").value || "#333333";
        node.strokeThickness = parseFloat(document.getElementById("configStroke").value) || 2;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addVerticalRect() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const fill = document.getElementById("configFill").value || "#FFD700";
        const node = new Node(x, y, "New Vertical Rect", "verticalRect", fill);
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = document.getElementById("configBorder").value || "#333333";
        node.strokeThickness = parseFloat(document.getElementById("configStroke").value) || 2;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addFloatingText() {
        const x = canvas.width / 2 / zoomLevel;
        const y = canvas.height / 2 / zoomLevel;
        const node = new Node(x, y, "New Floating Text", "floating", "transparent");
        node.textColor = document.getElementById("configText").value || "#000000";
        node.strokeColor = "transparent";
        node.strokeThickness = 0;
        node.manualScale = parseFloat(document.getElementById("configScale").value) || 1;
        mindMap.addNode(node);
        resetConfigDefaults();
      }

      function addImage() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/jpeg, image/png, image/gif";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (event) {
            const img = new Image();
            img.onload = function () {
              const x = canvas.width / 2 / zoomLevel;
              const y = canvas.height / 2 / zoomLevel;
              const node = new Node(x, y, "", "image", "transparent");
              node.image = img;
              node.manualScale = 1;
              node.strokeColor = "transparent";
              node.strokeThickness = 0;
              mindMap.addNode(node);
              resetConfigDefaults();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        };
        input.click();
      }

      function resetConfigDefaults() {
        document.getElementById("configFill").value = "#FFD700";
        document.getElementById("configText").value = "#000000";
        document.getElementById("configBorder").value = "#333333";
        document.getElementById("configStroke").value = "2";
        document.getElementById("configScale").value = "1";
        document.getElementById("configFont").value = "Roboto, Arial, sans-serif";
        document.getElementById("configFontSize").value = "16";
        document.getElementById("configBold").checked = false;
        document.getElementById("configItalic").checked = false;
      }

      function setMode(newMode) {
        currentMode = newMode;
        connectionSourceNode = null;
        updateStatus();
      }

      function zoomIn() {
        zoomLevel *= 1.1;
        scheduleDraw();
        updateStatus();
      }

      function zoomOut() {
        zoomLevel /= 1.1;
        scheduleDraw();
        updateStatus();
      }

      function deleteNode() {
        if (editorModal.style.display !== "block") {
          if (mindMap.selectedNode) {
            mindMap.deleteNode(mindMap.selectedNode);
          } else {
            alert("No node selected to delete.");
          }
        }
      }

      function saveAsImage() {
        const dataURL = canvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = "mindmap.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function saveAsJpeg() {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.fillStyle = "white";
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.drawImage(canvas, 0, 0);
        const dataURL = tempCanvas.toDataURL("image/jpeg");
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = "mindmap.jpeg";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function updateStatus() {
        document.getElementById("status").textContent =
          "Mode: " +
          (currentMode === Mode.SELECT
            ? "Select/Move"
            : currentMode.charAt(0).toUpperCase() + currentMode.slice(1)) +
          " | Zoom: " +
          Math.round(zoomLevel * 100) +
          "%";
      }

      /***********************
       * Keyboard Shortcuts
       ***********************/
      window.addEventListener("keydown", (event) => {
        if (editorModal.style.display === "block" && editorArea.contains(event.target)) {
          return;
        }
        // Undo/Redo
        if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "z" && !event.shiftKey) {
          event.preventDefault();
          undo();
        } else if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key.toLowerCase() === "z") {
          event.preventDefault();
          redo();
        }
        // Delete
        else if (event.key === "Delete" && document.activeElement !== editorArea) {
          deleteNode();
        }
        // Scale up/down node
        else if (mindMap.selectedNode && currentMode === Mode.SELECT) {
          if (event.key === "=" || event.key === "+" || event.keyCode === 187) {
            if (mindMap.selectedNode.shape === "circle") {
              mindMap.selectedNode.manualScale = Math.max(MIN_CIRCLE_SCALE, mindMap.selectedNode.manualScale + 0.1);
            } else {
              mindMap.selectedNode.manualScale = Math.max(0.1, mindMap.selectedNode.manualScale + 0.1);
            }
            scheduleDraw();
            pushState();
            document.getElementById("configScale").value = mindMap.selectedNode.manualScale;
          } else if (event.key === "-" || event.key === "‚Äì" || event.keyCode === 189) {
            if (mindMap.selectedNode.shape === "circle") {
              mindMap.selectedNode.manualScale = Math.max(MIN_CIRCLE_SCALE, mindMap.selectedNode.manualScale - 0.1);
            } else {
              mindMap.selectedNode.manualScale = Math.max(0.1, mindMap.selectedNode.manualScale - 0.1);
            }
            scheduleDraw();
            pushState();
            document.getElementById("configScale").value = mindMap.selectedNode.manualScale;
          }
        }
      });

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        scheduleDraw();
      });

      // Set up initial state
      pushState();

      // Provide reading mode toggling
      document.getElementById("readingMode").addEventListener("change", function () {
        editorArea.style.pointerEvents = this.checked ? "none" : "auto";
        makeDraggable(editorModal);
      });

      // Scale images or shapes with dedicated toolbar buttons
      function scaleImage(delta) {
        const selected = mindMap.selectedNode;
        if (!selected) return;
        if (selected.shape === "circle") {
          selected.manualScale = Math.max(MIN_CIRCLE_SCALE, selected.manualScale + delta);
        } else {
          selected.manualScale = Math.max(0.1, selected.manualScale + delta);
        }
        scheduleDraw();
        pushState();
        document.getElementById("configScale").value = selected.manualScale;
      }

      // Toggle the main toolbar, also close any open windows
      function toggleToolbar() {
        const toolbar = document.getElementById("toolbar");
        toolbar.style.display = (toolbar.style.display === "none") ? "flex" : "none";
        // Also close editor/config if they are open
        editorModal.style.display = "none";
        configModal.style.display = "none";
      }
    </script>
  </body>
</html>
